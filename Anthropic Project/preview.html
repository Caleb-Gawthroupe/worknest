<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Worksheet Preview - Worksheet Creator</title>
    <script>
        // Polyfill for older browsers (inline to avoid CDN issues)
        if (!window.Promise) {
            document.write('<script src="https://cdn.jsdelivr.net/npm/core-js-bundle@3/minified.js"><\/script>');
        }
    </script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            }
        };
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
        }

        .chat-bubble {
            animation: slideInUp 0.3s ease forwards;
        }

        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .typing-indicator {
            animation: pulse 1.5s infinite;
        }

        .pdf-container {
            background: #f8fafc;
            border-radius: 12px;
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
        }

        .chat-input {
            transition: all 0.3s ease;
        }

        .chat-input:focus {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px -5px rgba(16, 185, 129, 0.2);
        }

        .quick-action {
            transition: all 0.2s ease;
        }

        .quick-action:hover {
            transform: scale(1.05);
        }

        .pdf-page {
            background: white;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            margin-bottom: 1rem;
            border-radius: 8px;
            overflow: hidden;
        }

        .version-item {
            transition: all 0.2s ease;
            cursor: pointer;
        }

        .version-item:hover {
            background: #f1f5f9;
            transform: translateX(4px);
        }

        .version-item.active {
            background: #ecfdf5;
            border-left: 4px solid #10b981;
        }
    </style>
</head>

<body>
    <!-- Navigation -->
    <nav class="bg-white/90 backdrop-blur-md shadow-sm fixed w-full top-0 z-50">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between items-center h-16">
                <div class="flex items-center space-x-3">
                    <a href="index.html" class="flex items-center space-x-3 hover:opacity-80 transition-opacity">
                        <div
                            class="w-8 h-8 bg-gradient-to-br from-amber-400 to-emerald-500 rounded-lg flex items-center justify-center">
                            <span class="text-white font-bold text-sm">WC</span>
                        </div>
                        <span class="text-xl font-bold text-slate-800">Worksheet Creator</span>
                    </a>
                </div>
                <div class="flex items-center space-x-4">
                    <a href="index.html"
                        class="text-slate-600 hover:text-slate-900 transition-colors flex items-center space-x-1">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M10 19l-7-7m0 0l7-7m-7 7h18"></path>
                        </svg>
                        <span>Back to Home</span>
                    </a>
                    <span class="text-slate-600" id="worksheetTitle">Worksheet</span>
                    <div class="flex items-center space-x-2 mr-2">
                        <div id="clsiStatusDot" class="w-3 h-3 rounded-full bg-slate-300" title="CLSI Status: Unknown">
                        </div>
                        <button onclick="checkCLSIService()"
                            class="text-sm text-slate-600 hover:text-slate-900 underline">Check Connection</button>
                    </div>
                    <button id="downloadPDFBtn" onclick="downloadPDF(event)"
                        class="bg-emerald-500 text-white px-4 py-2 rounded-lg font-medium hover:bg-emerald-600 transition-colors">
                        Download PDF
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <div class="pt-16 h-screen flex">
        <!-- PDF Preview Area -->
        <div class="flex-1 p-6">
            <div class="h-full flex flex-col">
                <!-- PDF Controls -->
                <div class="flex items-center justify-between mb-4">
                    <div class="flex items-center space-x-4">
                        <h1 class="text-2xl font-bold text-slate-900">Worksheet Preview</h1>
                        <span class="text-sm text-slate-600 bg-slate-100 px-3 py-1 rounded-full">Page 1 of 2</span>
                    </div>
                    <div class="flex items-center space-x-2">
                        <button class="p-2 text-slate-600 hover:text-slate-900 transition-colors">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM13 10H7"></path>
                            </svg>
                        </button>
                        <button class="p-2 text-slate-600 hover:text-slate-900 transition-colors">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0zM10 7v3m0 0v3m0-3h3m-3 0H7"></path>
                            </svg>
                        </button>
                        <button class="p-2 text-slate-600 hover:text-slate-900 transition-colors">
                            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M12 18h.01M8 21h8a2 2 0 002-2V5a2 2 0 00-2-2H8a2 2 0 00-2 2v14a2 2 0 002 2z">
                                </path>
                            </svg>
                        </button>
                    </div>
                </div>

                <!-- PDF Display -->
                <div class="flex-1 overflow-auto">
                    <div class="max-w-4xl mx-auto p-6">
                        <div class="pdf-page bg-white rounded-lg shadow-lg"
                            style="height: 800px; padding: 0; overflow: hidden;">
                            <div id="loadingContainer" class="hidden flex items-center justify-center h-full">
                                <div class="text-center">
                                    <div
                                        class="animate-spin rounded-full h-12 w-12 border-b-2 border-emerald-500 mx-auto mb-4">
                                    </div>
                                    <p class="text-slate-600">Compiling PDF...</p>
                                </div>
                            </div>
                            <iframe id="pdfViewer" class="w-full h-full hidden" frameborder="0"></iframe>
                            <div id="latexContainer" class="text-slate-900 p-8 h-full overflow-auto hidden">
                                <div class="text-center text-slate-500 py-12">
                                    <p>Loading worksheet...</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Chat Sidebar -->
        <div class="w-96 bg-white border-l border-slate-200 flex flex-col">
            <!-- Chat Header -->
            <div class="p-4 border-b border-slate-200">
                <h3 class="text-lg font-semibold text-slate-900 mb-2">AI Assistant</h3>
                <p class="text-sm text-slate-600">Chat to refine your worksheet</p>
            </div>

            <!-- Chat Messages -->
            <div class="flex-1 overflow-y-auto p-4 space-y-4" id="chatMessages">
                <!-- Welcome Message - will be added by JavaScript -->

                <!-- Typing Indicator -->
                <div class="chat-bubble" id="typingIndicator" style="display: none;">
                    <div class="flex items-start space-x-3">
                        <div
                            class="w-8 h-8 bg-gradient-to-br from-emerald-500 to-teal-600 rounded-lg flex items-center justify-center flex-shrink-0">
                            <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                    d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z">
                                </path>
                            </svg>
                        </div>
                        <div class="bg-slate-100 rounded-2xl p-3">
                            <div class="flex space-x-1">
                                <div class="w-2 h-2 bg-slate-400 rounded-full typing-indicator"></div>
                                <div class="w-2 h-2 bg-slate-400 rounded-full typing-indicator"
                                    style="animation-delay: 0.2s;"></div>
                                <div class="w-2 h-2 bg-slate-400 rounded-full typing-indicator"
                                    style="animation-delay: 0.4s;"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Chat Input -->
            <div class="p-4 border-t border-slate-200">
                <div class="flex space-x-2">
                    <input type="text" id="chatInput" placeholder="Ask me to modify your worksheet..."
                        class="flex-1 p-3 border border-slate-200 rounded-xl chat-input focus:outline-none focus:ring-2 focus:ring-emerald-500"
                        onkeypress="handleChatKeyPress(event)">
                    <button onclick="sendMessage()"
                        class="bg-emerald-500 text-white p-3 rounded-xl hover:bg-emerald-600 transition-colors">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path>
                        </svg>
                    </button>
                </div>
            </div>
        </div>

        <!-- Version History Sidebar -->
        <div class="w-64 bg-slate-50 border-l border-slate-200 flex flex-col" id="versionSidebar"
            style="display: none;">
            <div class="p-4 border-b border-slate-200">
                <div class="flex items-center justify-between">
                    <h3 class="text-lg font-semibold text-slate-900">Version History</h3>
                    <button onclick="toggleVersionSidebar()" class="text-slate-600 hover:text-slate-900">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M6 18L18 6M6 6l12 12"></path>
                        </svg>
                    </button>
                </div>
            </div>

            <div class="flex-1 overflow-y-auto p-4 space-y-2">
                <div class="version-item active p-3 rounded-lg">
                    <div class="text-sm font-medium text-slate-900">Current Version</div>
                    <div class="text-xs text-slate-600">2 minutes ago</div>
                    <div class="text-xs text-slate-500 mt-1">Added geometry problems</div>
                </div>

                <div class="version-item p-3 rounded-lg">
                    <div class="text-sm font-medium text-slate-900">Version 1</div>
                    <div class="text-xs text-slate-600">5 minutes ago</div>
                    <div class="text-xs text-slate-500 mt-1">Initial algebra worksheet</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // API Configuration
        const API_KEY = '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';
        const API_MODEL = 'openai/gpt-oss-20b:free';
        const API_BASE_URL = 'https://openrouter.ai/api/v1';

        // Global state
        let currentLaTeX = '';
        let chatHistory = [];

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function () {
            loadWorksheet();
            initializeChat();
            document.getElementById('chatInput').focus();
        });

        function initializeChat() {
            // Add welcome message
            addChatMessage('Hi! I\'m your AI assistant. I can help you modify this worksheet. Try asking me to add more problems, change the difficulty, or modify the format.', 'ai');

            // Add quick action buttons
            const chatMessages = document.getElementById('chatMessages');
            const quickActionsDiv = document.createElement('div');
            quickActionsDiv.className = 'chat-bubble';
            quickActionsDiv.innerHTML = `
                <div class="grid grid-cols-2 gap-2">
                    <button class="quick-action bg-blue-50 text-blue-700 px-3 py-2 rounded-lg text-xs font-medium hover:bg-blue-100" onclick="sendQuickAction('Add more problems')">
                        Add more problems
                    </button>
                    <button class="quick-action bg-green-50 text-green-700 px-3 py-2 rounded-lg text-xs font-medium hover:bg-green-100" onclick="sendQuickAction('Make it harder')">
                        Make it harder
                    </button>
                    <button class="quick-action bg-purple-50 text-purple-700 px-3 py-2 rounded-lg text-xs font-medium hover:bg-purple-100" onclick="sendQuickAction('Add visual elements')">
                        Add visual elements
                    </button>
                    <button class="quick-action bg-orange-50 text-orange-700 px-3 py-2 rounded-lg text-xs font-medium hover:bg-orange-100" onclick="sendQuickAction('Change format')">
                        Change format
                    </button>
                </div>
            `;
            chatMessages.appendChild(quickActionsDiv);
        }

        function loadWorksheet() {
            // Load LaTeX from sessionStorage
            const latex = sessionStorage.getItem('worksheetLaTeX');
            const metadata = JSON.parse(sessionStorage.getItem('worksheetMetadata') || '{}');

            if (latex) {
                currentLaTeX = latex;
                renderLaTeX(latex);

                // Update title if metadata available
                if (metadata.subject && metadata.gradeLevel) {
                    const title = document.querySelector('nav span.text-slate-600');
                    if (title) {
                        title.textContent = `${metadata.gradeLevel} Grade ${metadata.subject.charAt(0).toUpperCase() + metadata.subject.slice(1)} Worksheet`;
                    }
                }
            } else {
                // Show message if no worksheet loaded
                document.querySelector('.flex-1.overflow-auto').innerHTML = `
                    <div class="max-w-4xl mx-auto p-8 text-center">
                        <p class="text-slate-600">No worksheet loaded. Please generate a worksheet first.</p>
                    </div>
                `;
            }
        }

        async function renderLaTeX(latex) {
            const container = document.getElementById('latexContainer');
            const pdfViewer = document.getElementById('pdfViewer');
            const loadingContainer = document.getElementById('loadingContainer');

            if (!container || !pdfViewer || !loadingContainer) return;

            // Show loading state
            container.classList.add('hidden');
            pdfViewer.classList.add('hidden');
            loadingContainer.classList.remove('hidden');

            try {
                // Try to compile to PDF first
                console.log('Attempting to compile PDF for preview...');
                const pdfBlob = await compileLaTeXToPDF(latex);

                if (pdfBlob) {
                    // Success! Show PDF
                    const pdfUrl = URL.createObjectURL(pdfBlob);
                    pdfViewer.src = pdfUrl;
                    pdfViewer.classList.remove('hidden');
                    loadingContainer.classList.add('hidden');

                    // Cache the blob for download
                    window.currentPdfBlob = pdfBlob;
                    return;
                }
            } catch (error) {
                console.warn('PDF preview compilation failed, falling back to HTML:', error);
                showNotification('Preview running in fallback mode (CLSI unavailable)', 'error');
            }

            // Fallback to HTML rendering
            loadingContainer.classList.add('hidden');
            container.classList.remove('hidden');

            // Convert LaTeX to HTML (simplified rendering)
            let html = convertLaTeXToHTML(latex);
            container.innerHTML = html;

            // Render math with MathJax
            if (window.MathJax && window.MathJax.typesetPromise) {
                MathJax.typesetPromise([container]).catch(function (err) {
                    console.error('MathJax rendering error:', err);
                });
            } else if (window.MathJax && window.MathJax.typeset) {
                MathJax.typeset([container]);
            }
        }

        // Helper function to process nested commands recursively
        function processNestedCommands(text, maxDepth = 10) {
            if (maxDepth <= 0) return text;

            // Process text formatting commands (may be nested)
            text = text.replace(/\\textbf\{((?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*)\}/g, (match, content) => {
                return `<strong>${processNestedCommands(content, maxDepth - 1)}</strong>`;
            });
            text = text.replace(/\\textit\{((?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*)\}/g, (match, content) => {
                return `<em>${processNestedCommands(content, maxDepth - 1)}</em>`;
            });
            text = text.replace(/\\emph\{((?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*)\}/g, (match, content) => {
                return `<em>${processNestedCommands(content, maxDepth - 1)}</em>`;
            });
            text = text.replace(/\\texttt\{((?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*)\}/g, (match, content) => {
                return `<code class="bg-slate-100 px-1 rounded">${processNestedCommands(content, maxDepth - 1)}</code>`;
            });
            text = text.replace(/\\textsc\{((?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*)\}/g, (match, content) => {
                return `<span style="font-variant: small-caps;">${processNestedCommands(content, maxDepth - 1)}</span>`;
            });
            text = text.replace(/\\underline\{((?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*)\}/g, (match, content) => {
                if (content.trim() === '' || content.includes('\\hspace')) {
                    return '<span class="border-b border-slate-400 inline-block" style="min-width: 2em;"></span>';
                }
                return `<span class="border-b border-slate-400">${processNestedCommands(content, maxDepth - 1)}</span>`;
            });

            return text;
        }

        function convertLaTeXToHTML(latex) {
            // Basic LaTeX to HTML conversion
            let html = latex;
            console.log('Starting LaTeX to HTML conversion...');

            // Extract and handle title, author, date, maketitle
            let title = '';
            let author = '';
            let date = '';

            html = html.replace(/\\title\{([^\}]+)\}/g, (match, titleText) => {
                title = titleText;
                return '';
            });
            html = html.replace(/\\author\{([^\}]+)\}/g, (match, authorText) => {
                author = authorText;
                return '';
            });
            html = html.replace(/\\date\{([^\}]*)\}/g, (match, dateText) => {
                date = dateText;
                return '';
            });
            html = html.replace(/\\maketitle/g, () => {
                let titleBlock = '<div class="text-center mb-8 pb-6 border-b-2 border-slate-300">';
                if (title) titleBlock += `<h1 class="text-3xl font-bold text-slate-900 mb-2">${title}</h1>`;
                if (author) titleBlock += `<p class="text-lg text-slate-700 mb-1">${author}</p>`;
                if (date) titleBlock += `<p class="text-sm text-slate-600">${date}</p>`;
                titleBlock += '</div>';
                return titleBlock;
            });

            // Remove document structure and package commands (more comprehensive)
            html = html.replace(/\\documentclass\[.*?\]\{.*?\}/g, '');
            html = html.replace(/\\documentclass\{.*?\}/g, '');
            html = html.replace(/\\usepackage\[.*?\]\{.*?\}/g, '');
            html = html.replace(/\\usepackage\{.*?\}/g, '');
            html = html.replace(/\\geometry\{[^\}]*\}/g, '');
            html = html.replace(/\\pagestyle\{[^\}]*\}/g, '');
            html = html.replace(/\\fancyhf\{\}/g, '');
            html = html.replace(/\\fancyhead\[L\]\{[^\}]*\}/g, '');
            html = html.replace(/\\fancyhead\[R\]\{[^\}]*\}/g, '');
            html = html.replace(/\\fancyhead\[C\]\{[^\}]*\}/g, '');
            html = html.replace(/\\fancyfoot\[L\]\{[^\}]*\}/g, '');
            html = html.replace(/\\fancyfoot\[R\]\{[^\}]*\}/g, '');
            html = html.replace(/\\fancyfoot\[C\]\{[^\}]*\}/g, '');
            html = html.replace(/\\begin\{document\}/g, '');
            html = html.replace(/\\end\{document\}/g, '');

            // Remove titleformat and other formatting commands (titlesec package) - handle all variations
            html = html.replace(/\\titleformat\{[^\}]*\}(\{([^\}]*)\})*\{[^\}]*\}/g, '');

            // Remove label commands (they're for cross-referencing, not display)
            html = html.replace(/\\label\{[^\}]*\}/g, '');

            // Remove more LaTeX commands that don't have HTML equivalents
            html = html.replace(/\\setlength\{[^\}]*\}\{[^\}]*\}/g, '');
            html = html.replace(/\\setcounter\{[^\}]*\}\{[^\}]*\}/g, '');
            html = html.replace(/\\renewcommand\*?\{[^\}]*\}(\{([^\}]*)\})*\{[^\}]*\}/g, '');
            html = html.replace(/\\newcommand\*?\{[^\}]*\}(\{([^\}]*)\})*\{[^\}]*\}/g, '');
            html = html.replace(/\\def\\?[a-zA-Z@]+[^a-zA-Z@](\{([^\}]*)\})*\{[^\}]*\}/g, '');
            html = html.replace(/\\linewidth/g, '100%');
            html = html.replace(/\\textwidth/g, '100%');
            html = html.replace(/\\baselineskip/g, '');
            html = html.replace(/\\parindent/g, '');

            // Remove ref commands (cross-references)
            html = html.replace(/\\ref\{[^\}]*\}/g, '?');
            html = html.replace(/\\pageref\{[^\}]*\}/g, '');

            // Remove caption commands (they're usually in figures/tables which we handle separately)
            html = html.replace(/\\caption\{([^\}]*)\}/g, '<div class="text-sm italic text-center mt-2">$1</div>');

            // Remove comment lines
            html = html.replace(/^%.*$/gm, '');

            // Handle itemize first (before processing items)
            html = html.replace(/\\begin\{itemize\}(\[.*?\])?/g, '<ul class="list-disc list-inside space-y-2 mb-6 ml-4">');
            html = html.replace(/\\end\{itemize\}/g, '</ul>');

            // Convert sections (handle labels and formatting) - do this first
            html = html.replace(/\\section\*\{([^\}]+)\}/g, '<h2 class="text-2xl font-bold text-slate-900 mb-4 mt-8">$1</h2>');
            html = html.replace(/\\section\{([^\}]+)\}/g, '<h2 class="text-2xl font-bold text-slate-900 mb-4 mt-8">$1</h2>');
            html = html.replace(/\\subsection\*?\{([^\}]+)\}/g, '<h3 class="text-xl font-semibold text-slate-800 mb-3 mt-6">$1</h3>');

            // Handle tabularx tables
            html = html.replace(/\\begin\{tabularx\}\{([^\}]+)\}\{([^\}]+)\}([\s\S]*?)\\end\{tabularx\}/g, (match, width, cols, content) => {
                // Parse column definitions
                const colDefs = cols.match(/[lcrX|@{}]/g) || [];
                let tableHTML = '<table class="w-full border-collapse border border-slate-300 my-4"><tbody>';

                // Remove table commands
                content = content.replace(/\\toprule/g, '');
                content = content.replace(/\\midrule/g, '');
                content = content.replace(/\\bottomrule/g, '');
                content = content.replace(/\\hline/g, '');

                // Split by rows (\\)
                const rows = content.split(/\\\\/).filter(r => r.trim());
                rows.forEach((row, rowIdx) => {
                    row = row.trim();
                    if (!row) return;

                    // Check if it's a header row (contains \textbf or starts with specific content)
                    const isHeader = rowIdx === 0 || row.includes('\\textbf');

                    // Split by & to get cells
                    const cells = row.split('&').map(c => c.trim());

                    if (cells.length > 0) {
                        tableHTML += isHeader ? '<tr class="bg-slate-100 font-semibold">' : '<tr>';
                        cells.forEach(cell => {
                            // Clean up cell content
                            cell = cell.replace(/\\textbf\{([^\}]+)\}/g, '<strong>$1</strong>');
                            cell = cell.replace(/\\textit\{([^\}]+)\}/g, '<em>$1</em>');
                            const cellTag = isHeader ? 'th' : 'td';
                            tableHTML += `<${cellTag} class="border border-slate-300 px-4 py-2">${cell}</${cellTag}>`;
                        });
                        tableHTML += '</tr>';
                    }
                });

                tableHTML += '</tbody></table>';
                return tableHTML;
            });

            // Handle enumerate blocks with custom labels (like [label=(\alph*)])
            html = html.replace(/\\begin\{enumerate\}(\[label=([^\]]+)\])?([\s\S]*?)\\end\{enumerate\}/g, (match, labelPart, labelDef, content) => {
                let itemNum = 0;
                const alphabet = 'abcdefghijklmnopqrstuvwxyz';

                // Determine label style
                let labelStyle = 'decimal'; // default
                let labelPrefix = '';
                let labelSuffix = '';

                if (labelDef) {
                    if (labelDef.includes('alph*')) {
                        labelStyle = 'lower-alpha';
                    } else if (labelDef.includes('Alph*')) {
                        labelStyle = 'upper-alpha';
                    } else if (labelDef.includes('roman*')) {
                        labelStyle = 'lower-roman';
                    } else if (labelDef.includes('Roman*')) {
                        labelStyle = 'upper-roman';
                    }

                    // Extract prefix/suffix from patterns like (\alph*) or [\alph*]
                    const prefixMatch = labelDef.match(/^([^a-zA-Z*]+)/);
                    const suffixMatch = labelDef.match(/([^a-zA-Z*]+)$/);
                    if (prefixMatch) labelPrefix = prefixMatch[1];
                    if (suffixMatch) labelSuffix = suffixMatch[1];
                }

                // Process each \item in this enumerate block
                const processedContent = content.replace(/\\item\s*([^\n]*)/g, (itemMatch, itemContent) => {
                    itemNum++;

                    // Generate label based on style
                    let label = itemNum.toString();
                    if (labelStyle === 'lower-alpha' && itemNum <= 26) {
                        label = alphabet[itemNum - 1];
                    } else if (labelStyle === 'upper-alpha' && itemNum <= 26) {
                        label = alphabet[itemNum - 1].toUpperCase();
                    } else if (labelStyle === 'lower-roman') {
                        label = toRoman(itemNum).toLowerCase();
                    } else if (labelStyle === 'upper-roman') {
                        label = toRoman(itemNum);
                    }

                    // Replace \arabic{counter} with the item number
                    let itemText = itemContent.replace(/\\arabic\{[^\}]*\}/g, itemNum.toString());
                    // Replace Q\arabic{counter} with Q + number
                    itemText = itemText.replace(/Q\\arabic\{[^\}]*\}/g, `Q${itemNum}`);

                    return `<li class="mb-2" style="list-style-type: ${labelStyle};">${labelPrefix}${label}${labelSuffix}. ${itemText}</li>`;
                });

                return `<ol class="space-y-3 mb-6 ml-4" style="list-style-type: ${labelStyle};">${processedContent}</ol>`;
            });

            // Helper function for Roman numerals
            function toRoman(num) {
                const values = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1];
                const numerals = ['M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'];
                let result = '';
                for (let i = 0; i < values.length; i++) {
                    while (num >= values[i]) {
                        result += numerals[i];
                        num -= values[i];
                    }
                }
                return result;
            }

            // Handle any remaining \arabic patterns (outside of enumerate)
            let questionCounter = 0;
            html = html.replace(/Q\\arabic\{[^\}]*\}/g, () => {
                questionCounter++;
                return `Q${questionCounter}`;
            });

            // Replace any remaining standalone \arabic
            html = html.replace(/\\arabic\{[^\}]*\}/g, '1');

            // Handle \item commands - convert to <li> tags
            // Process items within itemize/enumerate blocks that haven't been converted yet
            html = html.replace(/\\item\s+/g, '<li class="mb-2">');

            // Clean up any remaining LaTeX item markers
            html = html.replace(/\\item\s*/g, '');

            // Convert vspace
            html = html.replace(/\\vspace\{[^\}]+\}/g, '<br>');
            html = html.replace(/\\vspace\*\{[^\}]+\}/g, '<br>');

            // Convert newpage
            html = html.replace(/\\newpage/g, '<div class="page-break my-8 border-t-2 border-slate-300"></div>');
            html = html.replace(/\\clearpage/g, '<div class="page-break my-8"></div>');

            // Process nested text formatting commands (recursive)
            html = processNestedCommands(html);

            // Handle any remaining simple formatting commands
            html = html.replace(/\\textbf\{([^\}]+)\}/g, '<strong>$1</strong>');
            html = html.replace(/\\textit\{([^\}]+)\}/g, '<em>$1</em>');
            html = html.replace(/\\emph\{([^\}]+)\}/g, '<em>$1</em>');
            html = html.replace(/\\textsc\{([^\}]+)\}/g, '<span style="font-variant: small-caps;">$1</span>');
            html = html.replace(/\\texttt\{([^\}]+)\}/g, '<code class="bg-slate-100 px-1 rounded">$1</code>');
            html = html.replace(/\\textmd\{([^\}]+)\}/g, '$1');
            html = html.replace(/\\textsf\{([^\}]+)\}/g, '<span style="font-family: sans-serif;">$1</span>');
            html = html.replace(/\\textrm\{([^\}]+)\}/g, '<span style="font-family: serif;">$1</span>');

            // Convert underline (including empty ones for fill-in-the-blank)
            html = html.replace(/\\underline\{\\hspace\{([^\}]+)\}\}/g, '<span class="border-b border-slate-400 inline-block" style="min-width: 2em;"></span>');
            html = html.replace(/\\underline\{([^\}]*)\}/g, '<span class="border-b border-slate-400">$1</span>');

            // Convert spacing
            html = html.replace(/\\hspace\{[^\}]+\}/g, '&nbsp;');
            html = html.replace(/\\quad/g, '&nbsp;&nbsp;&nbsp;&nbsp;');
            html = html.replace(/\\qquad/g, '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;');

            // Convert line breaks
            html = html.replace(/\\\\/g, '<br>');
            html = html.replace(/\\newline/g, '<br>');

            // Convert centering
            html = html.replace(/\\begin\{center\}/g, '<div class="text-center">');
            html = html.replace(/\\end\{center\}/g, '</div>');

            // Convert multicols (simplified)
            html = html.replace(/\\begin\{multicols\}\{(\d+)\}/g, '<div class="grid grid-cols-$1 gap-4">');
            html = html.replace(/\\end\{multicols\}/g, '</div>');

            // Remove other LaTeX commands that don't render well
            html = html.replace(/\\setlength\{[^\}]*\}\{[^\}]*\}/g, '');
            html = html.replace(/\\setcounter\{[^\}]*\}\{[^\}]*\}/g, '');
            html = html.replace(/\\renewcommand\{[^\}]*\}\{[^\}]*\}/g, '');
            html = html.replace(/\\newcommand\{[^\}]*\}\{[^\}]*\}/g, '');
            html = html.replace(/\\renewcommand\*\{[^\}]*\}\{[^\}]*\}/g, '');
            html = html.replace(/\\linewidth/g, '100%');

            // Handle figures and images (basic support)
            html = html.replace(/\\begin\{figure\}(\[.*?\])?/g, '<div class="my-4">');
            html = html.replace(/\\end\{figure\}/g, '</div>');
            html = html.replace(/\\includegraphics(\[.*?\])?\{([^\}]+)\}/g, '<img src="$2" alt="Image" class="max-w-full h-auto my-2" />');

            // Handle equations (both inline and display)
            // These will be processed by MathJax, so just ensure they're marked properly
            html = html.replace(/\\begin\{equation\}/g, '\\[');
            html = html.replace(/\\end\{equation\}/g, '\\]');
            html = html.replace(/\\begin\{equation\*\}/g, '\\[');
            html = html.replace(/\\end\{equation\*\}/g, '\\]');
            html = html.replace(/\\begin\{align\}/g, '\\[');
            html = html.replace(/\\end\{align\}/g, '\\]');
            html = html.replace(/\\begin\{align\*\}/g, '\\[');
            html = html.replace(/\\end\{align\*\}/g, '\\]');

            html = html.replace(/\\flushright/g, '');

            // Handle quotes
            html = html.replace(/``([^'']+)''/g, '"$1"');
            html = html.replace(/`([^']+)'/g, "'$1'");

            // Handle special characters
            html = html.replace(/\\&/g, '&amp;');
            html = html.replace(/\\%/g, '%');
            html = html.replace(/\\#/g, '#');
            html = html.replace(/\\\$/g, '$');
            html = html.replace(/\\_/g, '_');
            html = html.replace(/\\\{/g, '{');
            html = html.replace(/\\\}/g, '}');

            // Clean up extra whitespace but preserve structure
            html = html.replace(/\n{3,}/g, '\n\n');

            // Log any remaining LaTeX commands that weren't converted (for debugging)
            const remainingCommands = html.match(/\\[a-zA-Z]+\{?/g);
            if (remainingCommands && remainingCommands.length > 0) {
                const uniqueCommands = [...new Set(remainingCommands)].slice(0, 10);
                console.warn('Unconverted LaTeX commands found:', uniqueCommands);
            }

            return `<div class="prose prose-slate max-w-none text-slate-900 leading-relaxed">${html}</div>`;
        }

        // This function is assumed to exist elsewhere in the full script,
        // but its relevant part for the change is included here based on the diff.
        // It handles rendering LaTeX, potentially to PDF or HTML.
        async function renderLaTeX(latex) {
            const container = document.getElementById('latexContainer');
            const pdfViewer = document.getElementById('pdfViewer');
            const loadingContainer = document.getElementById('loadingContainer');

            if (!container || !pdfViewer || !loadingContainer) return;

            // Show loading state
            container.classList.add('hidden');
            pdfViewer.classList.add('hidden');
            loadingContainer.classList.remove('hidden');

            try {
                // Try to compile to PDF first
                console.log('Attempting to compile PDF for preview...');
                const pdfBlob = await compileLaTeXToPDF(latex);

                if (pdfBlob) {
                    // Success! Show PDF
                    const pdfUrl = URL.createObjectURL(pdfBlob) + '#toolbar=0&navpanes=0&scrollbar=0';
                    pdfViewer.src = pdfUrl;
                    pdfViewer.classList.remove('hidden');
                    loadingContainer.classList.add('hidden');

                    // Cache the blob for download
                    window.currentPdfBlob = pdfBlob;
                    return;
                }
            } catch (error) {
                console.warn('PDF preview compilation failed, falling back to HTML:', error);
                showNotification('Preview running in fallback mode (CLSI unavailable)', 'error');
            }

            // Fallback to HTML rendering
            loadingContainer.classList.add('hidden');
            container.classList.remove('hidden');

            // Convert LaTeX to HTML (simplified rendering)
            let html = convertLaTeXToHTML(latex);
            container.innerHTML = html;

            // Render math with MathJax
            if (window.MathJax && window.MathJax.typesetPromise) {
                MathJax.typesetPromise([container]).catch(function (err) {
                    console.error('MathJax rendering error:', err);
                });
            } else if (window.MathJax && window.MathJax.typeset) {
                MathJax.typeset([container]);
            }
        }

        // Chat functionality
        async function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();

            if (!message) return;

            // Add user message
            addChatMessage(message, 'user');
            input.value = '';

            // Show typing indicator
            showTypingIndicator();

            try {
                // Call API to modify worksheet
                const response = await callChatAPI(message);
                hideTypingIndicator();

                // Show friendly message (not LaTeX code)
                addChatMessage(response.message || 'I\'ve updated the worksheet for you.', 'ai');

                // Update LaTeX if provided and re-render
                if (response.latex && response.latex.trim()) {
                    currentLaTeX = response.latex.trim();
                    sessionStorage.setItem('worksheetLaTeX', currentLaTeX);

                    // Re-render the worksheet with updated LaTeX
                    renderLaTeX(currentLaTeX);

                    // Show visual feedback that worksheet was updated
                    // Target both containers to cover both PDF and HTML modes
                    const pdfViewer = document.getElementById('pdfViewer');
                    const htmlContainer = document.getElementById('latexContainer');

                    const activeContainer = !pdfViewer.classList.contains('hidden') ? pdfViewer : htmlContainer;

                    if (activeContainer) {
                        activeContainer.style.transition = 'opacity 0.3s';
                        activeContainer.style.opacity = '0.5';
                        setTimeout(() => {
                            activeContainer.style.opacity = '1';
                        }, 300);
                    }
                }
            } catch (error) {
                hideTypingIndicator();
                addChatMessage('Sorry, I encountered an error. Please try again.', 'ai');
                console.error('Chat API error:', error);
            }
        }

        async function callChatAPI(userMessage) {
            const latexContext = currentLaTeX ? currentLaTeX.substring(0, 2000) : 'No worksheet loaded yet.';
            const systemPrompt = `You are an AI assistant helping to edit a LaTeX worksheet. The user will ask you to modify the worksheet. 

CRITICAL INSTRUCTIONS:
1. When the user requests changes, you MUST return ONLY valid JSON in this exact format:
   {"message": "Brief friendly explanation of what you changed", "latex": "COMPLETE updated LaTeX code starting with \\documentclass and ending with \\end{document}"}

2. The "message" should be a short, friendly explanation (1-2 sentences) - DO NOT include LaTeX code in the message.

3. The "latex" field must contain the COMPLETE, updated LaTeX document - not just the changes, but the entire document.

4. If the user is just asking a question or doesn't need LaTeX changes, return: {"message": "your response", "latex": null}

5. DO NOT include any markdown code blocks, explanations, or text outside the JSON. Return ONLY the JSON object.

Current worksheet LaTeX (first 2000 chars): ${latexContext}...`;

            const response = await fetch(`${API_BASE_URL}/chat/completions`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${API_KEY}`,
                    'HTTP-Referer': window.location.origin,
                    'X-Title': 'Worksheet Creator'
                },
                body: JSON.stringify({
                    model: API_MODEL,
                    messages: [
                        {
                            role: 'system',
                            content: systemPrompt
                        },
                        ...chatHistory.map(msg => ({
                            role: msg.role,
                            content: msg.content
                        })),
                        {
                            role: 'user',
                            content: userMessage
                        }
                    ],
                    temperature: 0.7,
                    max_tokens: 4000
                })
            });

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                throw new Error(errorData.error?.message || `API error: ${response.status}`);
            }

            const data = await response.json();
            let content = data.choices[0].message.content.trim();

            // Try to parse JSON response
            let result;
            try {
                // Remove any markdown code blocks if present
                content = content.replace(/^```json\n?/g, '').replace(/^```\n?/g, '').replace(/```$/g, '');

                // Extract JSON from response
                const jsonMatch = content.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    result = JSON.parse(jsonMatch[0]);
                } else {
                    result = { message: content, latex: null };
                }
            } catch (e) {
                console.error('JSON parse error:', e, 'Content:', content);
                // If not JSON, treat as plain message
                result = { message: content, latex: null };
            }

            // Update chat history (store the user message and our parsed response)
            chatHistory.push({ role: 'user', content: userMessage });
            chatHistory.push({ role: 'assistant', content: JSON.stringify(result) });

            return result;
        }

        async function sendQuickAction(action) {
            addChatMessage(action, 'user');
            showTypingIndicator();

            try {
                const response = await callChatAPI(action);
                hideTypingIndicator();

                // Show friendly message (not LaTeX code)
                addChatMessage(response.message || 'I\'ve updated the worksheet for you.', 'ai');

                // Update LaTeX if provided and re-render
                if (response.latex && response.latex.trim()) {
                    currentLaTeX = response.latex.trim();
                    sessionStorage.setItem('worksheetLaTeX', currentLaTeX);

                    // Re-render the worksheet with updated LaTeX
                    renderLaTeX(currentLaTeX);

                    // Show visual feedback
                    const container = document.getElementById('latexContainer');
                    if (container) {
                        container.style.opacity = '0.7';
                        setTimeout(() => {
                            container.style.opacity = '1';
                        }, 300);
                    }
                }
            } catch (error) {
                hideTypingIndicator();
                addChatMessage('Sorry, I encountered an error. Please try again.', 'ai');
                console.error('Chat API error:', error);
            }
        }

        function handleChatKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        function addChatMessage(message, sender) {
            const chatMessages = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'chat-bubble';

            if (sender === 'user') {
                messageDiv.innerHTML = `
                    <div class="flex items-start space-x-3 justify-end">
                        <div class="bg-emerald-500 text-white rounded-2xl p-3 max-w-xs">
                            <p class="text-sm">${message}</p>
                        </div>
                        <div class="w-8 h-8 bg-slate-400 rounded-lg flex items-center justify-center flex-shrink-0">
                            <span class="text-white text-xs font-bold">You</span>
                        </div>
                    </div>
                `;
            } else {
                messageDiv.innerHTML = `
                    <div class="flex items-start space-x-3">
                        <div class="w-8 h-8 bg-gradient-to-br from-emerald-500 to-teal-600 rounded-lg flex items-center justify-center flex-shrink-0">
                            <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"></path>
                            </svg>
                        </div>
                        <div class="bg-slate-100 rounded-2xl p-3 max-w-xs">
                            <p class="text-sm text-slate-800">${message}</p>
                        </div>
                    </div>
                `;
            }

            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function showTypingIndicator() {
            document.getElementById('typingIndicator').style.display = 'block';
            document.getElementById('chatMessages').scrollTop = document.getElementById('chatMessages').scrollHeight;
        }

        function hideTypingIndicator() {
            document.getElementById('typingIndicator').style.display = 'none';
        }


        function toggleVersionSidebar() {
            const sidebar = document.getElementById('versionSidebar');
            sidebar.style.display = sidebar.style.display === 'none' ? 'flex' : 'none';
        }

        async function downloadPDF(event) {
            if (!currentLaTeX) {
                alert('No worksheet to download. Please generate a worksheet first.');
                return;
            }

            // Get worksheet title
            const title = document.getElementById('worksheetTitle')?.textContent || 'Worksheet';
            const pdfFilename = `${title.replace(/\s+/g, '_')}.pdf`;
            const texFilename = `${title.replace(/\s+/g, '_')}.tex`;

            // Get button element (from event or by ID)
            const button = event?.target || document.getElementById('downloadPDFBtn');
            const originalText = button ? button.innerHTML : '';

            try {
                // If we already have a compiled PDF blob from the preview, use it!
                if (window.currentPdfBlob) {
                    const pdfUrl = URL.createObjectURL(window.currentPdfBlob);
                    const pdfLink = document.createElement('a');
                    pdfLink.href = pdfUrl;
                    pdfLink.download = pdfFilename;
                    document.body.appendChild(pdfLink);
                    pdfLink.click();
                    document.body.removeChild(pdfLink);
                    URL.revokeObjectURL(pdfUrl); // Revoke the URL after use

                    if (button) {
                        button.innerHTML = originalText;
                        button.disabled = false;
                    }
                    return;
                }

                // Show loading indicator
                if (button) {
                    button.innerHTML = '<span class="animate-spin"></span> Compiling PDF...';
                    button.disabled = true;
                }

                // Download LaTeX file first
                const latexBlob = new Blob([currentLaTeX], { type: 'text/plain' });
                const latexUrl = URL.createObjectURL(latexBlob);
                const latexLink = document.createElement('a');
                latexLink.href = latexUrl;
                latexLink.download = texFilename;
                document.body.appendChild(latexLink);
                latexLink.click();
                document.body.removeChild(latexLink);
                URL.revokeObjectURL(latexUrl);

                // Small delay to avoid browser blocking multiple downloads
                await new Promise(resolve => setTimeout(resolve, 100));

                // Compile LaTeX to PDF using compilation service
                const pdfBlob = await compileLaTeXToPDF(currentLaTeX);

                // Create download link for PDF
                const pdfUrl = URL.createObjectURL(pdfBlob);
                const pdfLink = document.createElement('a');
                pdfLink.href = pdfUrl;
                pdfLink.download = pdfFilename;
                document.body.appendChild(pdfLink);
                pdfLink.click();
                document.body.removeChild(pdfLink);
                URL.revokeObjectURL(pdfUrl);

                // Restore button
                if (button) {
                    button.innerHTML = originalText;
                    button.disabled = false;
                }

            } catch (error) {
                console.error('PDF compilation error:', error);

                // Warn user before fallback
                const useFallback = confirm(
                    'High-quality PDF compilation failed (CLSI service unreachable).\n\n' +
                    'Do you want to download a basic PDF instead?\n' +
                    '(Note: Mathematical symbols may not render correctly in the basic version)'
                );

                if (!useFallback) {
                    if (button) {
                        button.innerHTML = originalText;
                        button.disabled = false;
                    }
                    return;
                }

                // Fallback to HTML-to-PDF if LaTeX compilation fails
                try {
                    const container = document.getElementById('latexContainer');
                    if (container) {
                        const printContainer = container.cloneNode(true);
                        printContainer.style.padding = '2rem';
                        printContainer.style.backgroundColor = 'white';
                        printContainer.style.maxWidth = '8.5in';
                        printContainer.style.margin = '0 auto';

                        const opt = {
                            margin: [0.5, 0.5, 0.5, 0.5],
                            filename: pdfFilename, // Use the correct filename variable
                            image: { type: 'jpeg', quality: 0.98 },
                            html2canvas: {
                                scale: 2,
                                useCORS: true,
                                logging: false
                            },
                            jsPDF: {
                                unit: 'in',
                                format: 'letter',
                                orientation: 'portrait'
                            }
                        };

                        await html2pdf().set(opt).from(printContainer).save();

                        // Restore button on success
                        if (button) {
                            button.innerHTML = originalText;
                            button.disabled = false;
                        }
                        return;
                    }
                } catch (fallbackError) {
                    console.error('Fallback PDF generation error:', fallbackError);
                    alert('Error generating PDF. You can use the browser\'s Print function (Ctrl+P / Cmd+P) and save as PDF instead.');
                }

                // Restore button
                if (button) {
                    button.innerHTML = 'Download PDF';
                    button.disabled = false;
                }
            }
        }

        async function compileLaTeXToPDF(latexContent) {
            // Try multiple LaTeX compilation services in order
            // Note: Most LaTeX services don't support CORS from browsers
            // CLSI needs CORS headers configured or a proxy server
            const services = [
                compileWithLocalCLSI,
                compileWithQuickLaTeX,
                compileWithShareLaTeX
            ];

            console.log('Starting LaTeX compilation, trying', services.length, 'services...');

            for (let i = 0; i < services.length; i++) {
                const service = services[i];
                const serviceName = service.name;
                try {
                    console.log(`Trying service ${i + 1}/${services.length}: ${serviceName}`);
                    const pdf = await service(latexContent);
                    if (pdf && pdf.size > 0) {
                        console.log(` Success with ${serviceName}! PDF size: ${pdf.size} bytes`);
                        return pdf;
                    } else {
                        console.warn(`${serviceName} returned empty result`);
                    }
                } catch (error) {
                    console.warn(`${serviceName} failed:`, error.message);
                    continue;
                }
            }

            throw new Error('All LaTeX compilation services failed. Falling back to HTML-to-PDF.');
        }

        async function compileWithLocalCLSI(latexContent) {
            // Try to use a local CLSI instance if available
            // Use proxy URL if available to avoid CORS issues
            // Default to proxy on port 3014 (clsi-proxy.py)
            const CLSI_PROXY = localStorage.getItem('CLSI_PROXY_URL') || 'http://localhost:3014';
            const CLSI_URL = localStorage.getItem('CLSI_URL') || CLSI_PROXY;

            try {
                console.log('Attempting to compile with CLSI at:', CLSI_URL);

                // Generate a unique project ID
                const projectId = 'worksheet-' + Date.now();

                // Extract main file name (usually main.tex or first .tex file)
                const mainFile = 'main.tex';

                // Prepare the compilation request according to CLSI API
                const compileRequest = {
                    compile: {
                        options: {
                            compiler: 'pdflatex',
                            timeout: 60
                        },
                        rootResourcePath: mainFile,
                        resources: [{
                            path: mainFile,
                            content: latexContent
                        }]
                    }
                };

                console.log('Sending compilation request to CLSI...');

                // Try with CORS mode first
                let response;
                try {
                    response = await fetch(`${CLSI_URL}/project/${projectId}/compile`, {
                        method: 'POST',
                        mode: 'cors',
                        headers: {
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        },
                        body: JSON.stringify(compileRequest)
                    });
                } catch (corsError) {
                    // If CORS fails, CLSI doesn't support CORS from browser
                    console.warn('CLSI CORS failed - CLSI needs CORS headers or a proxy. Error:', corsError.message);
                    return null;
                }

                console.log('CLSI response status:', response.status);

                if (!response.ok) {
                    const errorText = await response.text().catch(() => 'Unknown error');
                    console.error('CLSI compilation failed:', response.status, errorText);
                    throw new Error(`CLSI compilation failed: ${response.status} - ${errorText.substring(0, 100)}`);
                }

                const result = await response.json();
                console.log('CLSI compilation result:', result);

                if (result.compile && result.compile.status === 'success' && result.compile.outputFiles) {
                    // Find the PDF output file
                    const pdfFile = result.compile.outputFiles.find(f => f.type === 'pdf');
                    if (pdfFile && pdfFile.url) {
                        console.log('PDF file found at:', pdfFile.url);
                        // Download the PDF - handle both absolute and relative URLs
                        // Rewrite the URL to use our proxy (CLSI_URL) instead of the direct CLSI service URL
                        // This ensures the download request goes through the CORS proxy
                        const pdfPath = pdfFile.url.replace(/^https?:\/\/[^\/]+/, '');
                        const pdfUrl = `${CLSI_URL}${pdfPath}`;
                        const pdfResponse = await fetch(pdfUrl);
                        if (pdfResponse.ok) {
                            console.log('PDF downloaded successfully');
                            return await pdfResponse.blob();
                        } else {
                            throw new Error(`Failed to download PDF: ${pdfResponse.status}`);
                        }
                    }
                } else if (result.compile && result.compile.status === 'error') {
                    throw new Error(`CLSI compilation error: ${result.compile.error || 'Unknown error'}`);
                }

                throw new Error('CLSI compilation succeeded but no PDF found');
            } catch (error) {
                console.warn('CLSI compilation failed:', error);
                // If CLSI_URL is not set or service is unavailable, return null
                if (error.message.includes('Failed to fetch') || error.message.includes('NetworkError')) {
                    console.info('CLSI service not reachable. Make sure it\'s running on', CLSI_URL);
                }
                return null;
            }
        }

        async function compileWithLatexOnline(latexContent) {
            // Skip latexonline.cc - it doesn't support CORS from browser
            // Would need a backend proxy to use this service
            console.log('Skipping latexonline.cc - CORS not supported from browser');
            return null;
        }

        async function compileWithQuickLaTeX(latexContent) {
            // Alternative: Try a different LaTeX compilation service that supports CORS
            // For now, return null as most services don't support browser CORS
            return null;
        }

        async function compileWithShareLaTeX(latexContent) {
            // Placeholder for additional compilation services
            return null;
        }

        // CLSI Status Check
        async function checkCLSIService() {
            const dot = document.getElementById('clsiStatusDot');
            const CLSI_PROXY = localStorage.getItem('CLSI_PROXY_URL') || 'http://localhost:3014';

            if (dot) {
                dot.className = 'w-3 h-3 rounded-full bg-yellow-400 animate-pulse';
                dot.title = 'Checking connection...';
            }

            try {
                console.log('Checking CLSI connection at:', CLSI_PROXY);

                // Try to fetch the proxy root or a health endpoint
                // The proxy supports OPTIONS for CORS, so we can try that or a simple GET
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 2000);

                const response = await fetch(CLSI_PROXY, {
                    method: 'GET',
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                // CLSI returns 404 for root, which is fine - it means we connected!
                if (response.ok || response.status === 404) {
                    console.log('CLSI Proxy is reachable');
                    if (dot) {
                        dot.className = 'w-3 h-3 rounded-full bg-emerald-500';
                        dot.title = 'CLSI Service Connected';
                    }
                    showNotification('CLSI Service Connected', 'success');
                    return true;
                } else {
                    throw new Error(`Status ${response.status}`);
                }
            } catch (error) {
                console.warn('CLSI Check Failed:', error);
                if (dot) {
                    dot.className = 'w-3 h-3 rounded-full bg-red-500';
                    dot.title = 'CLSI Service Unreachable';
                }

                let msg = 'CLSI Service Unreachable. ';
                if (error.name === 'AbortError') {
                    msg += 'Connection timed out.';
                } else {
                    msg += 'Is the proxy running?';
                }

                alert(`${msg}\n\nPlease run:\n1. ./start-clsi.sh\n2. python3 clsi-proxy.py`);
                return false;
            }
        }

        function showNotification(message, type = 'info') {
            // Simple toast notification
            const toast = document.createElement('div');
            toast.className = `fixed bottom-4 right-4 px-6 py-3 rounded-lg shadow-lg text-white transform transition-all duration-300 translate-y-10 opacity-0 z-50 ${type === 'success' ? 'bg-emerald-500' :
                type === 'error' ? 'bg-red-500' : 'bg-slate-800'
                }`;
            toast.textContent = message;
            document.body.appendChild(toast);

            // Animate in
            requestAnimationFrame(() => {
                toast.classList.remove('translate-y-10', 'opacity-0');
            });

            // Remove after 3s
            setTimeout(() => {
                toast.classList.add('translate-y-10', 'opacity-0');
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // Make downloadPDF available globally
        window.downloadPDF = downloadPDF;
        window.checkCLSIService = checkCLSIService;

        // Check status on load
        window.addEventListener('load', () => {
            // Small delay to let things settle
            setTimeout(checkCLSIService, 1000);
        });

    </script>
</body>

</html>